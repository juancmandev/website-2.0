<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title><![CDATA[juancmandev]]></title>
        <description><![CDATA[Welcome to juancmandev's website]]></description>
        <link>https://juancman.dev</link>
        <image>
            <url>https://juancman.dev/logo.png</url>
            <title>juancmandev</title>
            <link>https://juancman.dev</link>
        </image>
        <generator>RSS for Node</generator>
        <lastBuildDate>Tue, 20 Feb 2024 15:31:39 GMT</lastBuildDate>
        <atom:link href="https://juancman.dev/feed.xml" rel="self" type="application/rss+xml"/>
        <language><![CDATA[en]]></language>
        <item>
            <title><![CDATA[Build a fullstack web app]]></title>
            <description><![CDATA[<h1>Build a fullstack web app</h1>
<p><img src="/portfolio/build-a-fullstack-app/banner.png" alt="Banner with the tech stack used in this tutorial, Next.js, TailwindCSS, shadcn/ui, Prisma, PostgreSQL and Auth.js"><br><em>Tech stack used in this tutorial</em></p>
<p><PostData
  date="January 18, 2024"
  author="Juan Manzanero"
  github="https://github.com/juancmandev/fullstack-app"
/></p>
<h2>Content</h2>
<ol>
<li><a href="#1-introduction" target="_blank" rel="noopener noreferrer">Introduction</a></li>
<li><a href="#2-initial-setup" target="_blank" rel="noopener noreferrer">Initial setup</a><ol>
<li><a href="#21-install-shadcnui" target="_blank" rel="noopener noreferrer">Install shadcn/ui</a></li>
<li><a href="#22-create-a-postgresql-database-using-docker" target="_blank" rel="noopener noreferrer">Create a PostgreSQL database using Docker</a></li>
<li><a href="#23-install-prisma" target="_blank" rel="noopener noreferrer">Install Prisma</a></li>
<li><a href="#24-config-authjs" target="_blank" rel="noopener noreferrer">Config Auth.js</a></li>
</ol>
</li>
<li><a href="#3-improve-your-ui" target="_blank" rel="noopener noreferrer">Improve your UI</a></li>
<li><a href="#4-add-crud-functionality" target="_blank" rel="noopener noreferrer">Add CRUD functionality</a></li>
<li><a href="#5-conclusion" target="_blank" rel="noopener noreferrer">Conclusion</a></li>
</ol>
<h2>1. Introduction</h2>
<p>In this tutorial, we will develop a fullstack web app with the following tech stack:</p>
<ul>
<li><a href="https://nextjs.org/" target="_blank" rel="noopener noreferrer">Next.js</a> as meta-framework</li>
<li><a href="https://tailwindcss.com/" target="_blank" rel="noopener noreferrer">TailwindCSS</a> for styling</li>
<li><a href="https://ui.shadcn.com/" target="_blank" rel="noopener noreferrer">shadcn/ui</a> for UI components</li>
<li><a href="https://www.prisma.io/" target="_blank" rel="noopener noreferrer">Prisma</a> as ORM</li>
<li><a href="https://www.postgresql.org/" target="_blank" rel="noopener noreferrer">PostgreSQL</a> as database</li>
<li><a href="https://authjs.dev/" target="_blank" rel="noopener noreferrer">Auth.js</a> for authentication</li>
<li><a href="https://www.docker.com/" target="_blank" rel="noopener noreferrer">Docker</a> for creating an intance of a PostgreSQL database locally</li>
</ul>
<p>We&#39;ll learn some of the fundamentals of this tech stack, like using <strong>server components</strong> in Next.js, or creating <strong>API endpoints</strong> using the <strong>app router</strong>.</p>
<h2>2. Initial setup</h2>
<p>Let&#39;s start creating a new Next.js project, in your <strong>terminal</strong> run:</p>
<pre><code class="language-bash">npx create-next-app@latest
</code></pre>
<p>Make sure to mark <strong>Yes</strong> the following options:</p>
<ul>
<li>Would you like to use <strong>TypeScript</strong>?</li>
<li>Would you like to use <strong>ESLint</strong>?</li>
<li>Would you like to use <strong>Tailwind CSS</strong>?</li>
<li>Would you like to use <strong>&#39;src/&#39; directory</strong>?</li>
<li>Would you like to use <strong>App Router</strong>? (recommended)</li>
</ul>
<pre><code class="language-bash">&gt; What is your project named? fullstack-app
&gt; Would you like to use TypeScript? No / Yes
&gt; Would you like to use ESLint? No / Yes
&gt; Would you like to use Tailwind CSS? No / Yes
&gt; Would you like to use `src/` directory? No / Yes
&gt; Would you like to use App Router? (recommended) No / Yes
&gt; Would you like to customize the default import alias (@/*)? No / Yes
&gt; What import alias would you like configured? @/*
</code></pre>
<p>Wait until the dependencies installation is completed, then access to the project directory:</p>
<pre><code class="language-bash">cd fullstack-app
</code></pre>
<p>Open your code editor of your preference.</p>
<h3>2.1 Install shadcn/ui</h3>
<p>This components will help us a lot building the <strong>UI</strong> along with TailwindCSS.</p>
<p>First, initialize shadcn/ui:</p>
<pre><code class="language-bash">npx shadcn-ui@latest init
</code></pre>
<p>Make sure to config shadcn/ui according your project configuration.</p>
<p>You can check the <a href="https://ui.shadcn.com/docs" target="_blank" rel="noopener noreferrer">shadcn/ui docs</a> for every component that you could need, each components is installed individually.</p>
<h3>2.2 Create a PostgreSQL database using Docker</h3>
<p>Make sure to have <a href="https://www.docker.com/" target="_blank" rel="noopener noreferrer">Docker</a> installed in your machine.</p>
<p>First you need to pull a PostgreSQL image from Docker Hub:</p>
<pre><code class="language-bash">docker pull postgres
</code></pre>
<p>Then, create a container with the image:</p>
<pre><code class="language-bash">docker run --name my-postgres -e POSTGRES_PASSWORD=password -p 5432:5432 -d postgres
</code></pre>
<h3>2.3 Install Prisma</h3>
<p>Install Prisma using your dependency manager, in this case <strong>npm</strong>:</p>
<pre><code class="language-bash">npm install prisma -D
</code></pre>
<p>Now initialize Prisma:</p>
<pre><code class="language-bash">npx prisma init
</code></pre>
<p>A new <code>./prisma</code> direcotry will be created in the root of your project, with a schema.prisma file.</p>
<p>You&#39;ll create your schemas in this file.</p>
<p>Add this model as an example:</p>
<pre><code class="language-prisma">model User {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  email     String   @unique
  name      String?
}
</code></pre>
<p>Update your <code>.env</code> file with the following:</p>
<pre><code class="language-env">DATABASE_URL=&quot;postgresql://postgres:password@localhost:5432/postgres?schema=public&quot;
</code></pre>
<p>In the URL is your username (by default is postgres), your password (in this case password), the host (by default is localhost), the port (by default is 5432), the database name (by default is postgres) and the schema (by default is public).</p>
<p>Create your first migration to test if Prisma can connect to your local database:</p>
<pre><code class="language-bash">npx prisma migrate dev --name init
</code></pre>
<p>If everything is ok, you&#39;ll see a new /migrations directory with a new file inside.</p>
<blockquote>
<p>If you have an error, make sure you can connect to your local DB. Delete, and create the container again if necessary.</p>
</blockquote>
<h3>2.4 Config Auth.js</h3>
<p>Add this models to your <strong>prisma schema</strong>:</p>
<pre><code class="language-prisma">model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
</code></pre>
<p>These models are for <strong>Auth.js</strong>, now we can install it with the prisma adapter:</p>
<pre><code class="language-bash">npm install @prisma/client @auth/prisma-adapter
</code></pre>
<p>Instal nodemailer too, as we&#39;ll use magic links for authentication:</p>
<pre><code class="language-bash">npm install nodemailer -D
</code></pre>
<p>Now create a <code>src/utils/db.ts</code> and initialize <strong>prisma</strong>:</p>
<pre><code class="language-ts">import { PrismaClient } from &#39;@prisma/client&#39;;

const prismaClientSingleton = () =&gt; {
  return new PrismaClient();
};

declare global {
  var prisma: undefined | ReturnType&lt;typeof prismaClientSingleton&gt;;
}

const prisma = globalThis.prisma ?? prismaClientSingleton();

export default prisma;

if (process.env.NODE_ENV !== &#39;production&#39;) globalThis.prisma = prisma;
</code></pre>
<p>Then, create a <code>src/utils/auth.ts</code> file to config <strong>Auth.js</strong>:</p>
<pre><code class="language-ts">import type { NextAuthOptions } from &#39;next-auth&#39;;
import { PrismaAdapter } from &#39;@auth/prisma-adapter&#39;;
import EmailProvider from &#39;next-auth/providers/email&#39;;
import prisma from &#39;@/libs/db&#39;;
import { Adapter } from &#39;next-auth/adapters&#39;;

export const authOptions = {
  adapter: PrismaAdapter(prisma) as Adapter,
  providers: [
    EmailProvider({
      server: {
        host: process.env.EMAIL_SERVER_HOST,
        port: process.env.EMAIL_SERVER_PORT,
        auth: {
          user: process.env.EMAIL_SERVER_USER,
          pass: process.env.EMAIL_SERVER_PASSWORD,
        },
      },
      from: process.env.EMAIL_FROM,
    }),
  ],
  callbacks: {
    session: async ({ session, user }) =&gt; {
      return {
        ...session,
        user: user,
      };
    },
  },
} satisfies NextAuthOptions;
</code></pre>
<p>This config is for using an email provider, for this project we&#39;ll use <a href="https://resend.com/" target="_blank" rel="noopener noreferrer">Resend</a>.</p>
<p>Create an account and get the next credentials in your .env file:</p>
<ul>
<li>EMAIL_SERVER_HOST: smtp.resend.com</li>
<li>EMAIL_SERVER_PORT: 465</li>
<li>EMAIL_SERVER_USER: resend</li>
<li>EMAIL_FROM: onboarding@resend(dot)dev</li>
<li>EMAIL_SERVER_PASSWORD: yor api key</li>
</ul>
<p>Now, create a <code>src/pages/api/auth/[...nextauth]/route.ts</code> file:</p>
<pre><code class="language-ts">import { authOptions } from &#39;@/libs/auth&#39;;
import NextAuth from &#39;next-auth/next&#39;;

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };
</code></pre>
<p>This file is for handling the authentication in our app.</p>
<p>You can now authenticate users with a magic link sent by email.</p>
<p>Create a <code>src/app/auth/signin-form.tsx</code> file:</p>
<pre><code class="language-tsx">&#39;use client&#39;;

import { useState } from &#39;react&#39;;
import { signIn } from &#39;next-auth/react&#39;;

export default function SigninForm() {
  const [email, setEmail] = useState&lt;null | string&gt;(null);

  async function handleSubmit() {
    await signIn(&#39;email&#39;, {
      email,
      callbackUrl: `${window.location.origin}`,
    });
  }

  return (
    &lt;form className=&quot;mt-5 space-y-4&quot; action={handleSubmit}&gt;
      &lt;section className=&quot;flex flex-col gap-2&quot;&gt;
        &lt;label htmlFor=&quot;email&quot;&gt;Email&lt;/label&gt;
        &lt;input
          id=&quot;email&quot;
          type=&quot;email&quot;
          name=&quot;email&quot;
          onChange={(e) =&gt; setEmail(e.target.value)}
          className=&quot;w-max p-1 border border-slate-400&quot;
        /&gt;
      &lt;/section&gt;
      &lt;button type=&quot;submit&quot;&gt;Sign in&lt;/button&gt;
    &lt;/form&gt;
  );
}
</code></pre>
<p>Import it to your <code>src/app/auth/page.tsx</code> file:</p>
<pre><code class="language-tsx">import { authOptions } from &#39;@/libs/auth&#39;;
import { getServerSession } from &#39;next-auth&#39;;
import { redirect } from &#39;next/navigation&#39;;
import SigninForm from &#39;./form&#39;;

export default async function Signin() {
  const session = await getServerSession(authOptions);

  if (session) {
    return redirect(&#39;/&#39;);
  }

  return (
    &lt;&gt;
      &lt;h1&gt;Sign in&lt;/h1&gt;

      &lt;SigninForm /&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>As you can see, you can redirect users if they&#39;re not authenticated getting the session with <strong>getServerSession</strong>.</p>
<h2>3. Improve your UI</h2>
<p>Let&#39;s create a short posts like app.</p>
<p>First, add some shadcn/ui components and update your components, we&#39;ll create new components too:</p>
<pre><code class="language-bash">npx shadcn-ui@latest add button
</code></pre>
<pre><code class="language-bash">npx shadcn-ui@latest add dialog
</code></pre>
<pre><code class="language-bash">npx shadcn-ui@latest add input
</code></pre>
<pre><code class="language-bash">npx shadcn-ui@latest add textarea
</code></pre>
<pre><code class="language-bash">npx shadcn-ui@latest add form
</code></pre>
<pre><code class="language-bash">npx shadcn-ui@latest add label
</code></pre>
<pre><code class="language-bash">npx shadcn-ui@latest add sonner
</code></pre>
<p>We&#39;ll add the endpoints URL for these components, but we&#39;ll create them later.</p>
<p><code>src/app/auth/signin-form.tsx</code></p>
<p>Here we&#39;ll update the UI and add form validation.</p>
<pre><code class="language-tsx">&#39;use client&#39;;

import { signIn } from &#39;next-auth/react&#39;;
import { Button } from &#39;@/components/ui/button&#39;;
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from &#39;@/components/ui/form&#39;;
import { Input } from &#39;@/components/ui/input&#39;;
import { Textarea } from &#39;@/components/ui/textarea&#39;;
import { useForm } from &#39;react-hook-form&#39;;
import * as z from &#39;zod&#39;;
import { zodResolver } from &#39;@hookform/resolvers/zod&#39;;

const formSchema = z.object({
  email: z.string().email(),
});

export default function SigninForm() {
  const form = useForm&lt;z.infer&lt;typeof formSchema&gt;&gt;({
    resolver: zodResolver(formSchema),
    defaultValues: {
      email: &#39;&#39;,
    },
  });

  async function onSubmit({ email }: z.infer&lt;typeof formSchema&gt;) {
    await signIn(&#39;email&#39;, {
      email,
      callbackUrl: `${window.location.origin}`,
    });
  }

  return (
    &lt;Form {...form}&gt;
      &lt;form className=&quot;space-y-4&quot; onSubmit={form.handleSubmit(onSubmit)}&gt;
        &lt;FormField
          control={form.control}
          name=&quot;email&quot;
          render={({ field }) =&gt; (
            &lt;FormItem&gt;
              &lt;FormLabel&gt;Email&lt;/FormLabel&gt;
              &lt;FormControl&gt;
                &lt;Input placeholder=&quot;address@example.com&quot; {...field} /&gt;
              &lt;/FormControl&gt;
              &lt;FormMessage /&gt;
            &lt;/FormItem&gt;
          )}
        /&gt;
        &lt;Button className=&quot;w-full&quot; type=&quot;submit&quot;&gt;
          Send magic link
        &lt;/Button&gt;
      &lt;/form&gt;
    &lt;/Form&gt;
  );
}
</code></pre>
<p><code>src/components/post/create.tsx</code></p>
<p>Update UI components and form validation.</p>
<pre><code class="language-tsx">&#39;use client&#39;;

import { useState } from &#39;react&#39;;
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from &#39;@/components/ui/dialog&#39;;
import { Button } from &#39;@/components/ui/button&#39;;
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from &#39;@/components/ui/form&#39;;
import { Input } from &#39;@/components/ui/input&#39;;
import { Textarea } from &#39;@/components/ui/textarea&#39;;
import { useForm } from &#39;react-hook-form&#39;;
import * as z from &#39;zod&#39;;
import { zodResolver } from &#39;@hookform/resolvers/zod&#39;;
import { useRouter } from &#39;next/navigation&#39;;
import { toast } from &#39;sonner&#39;;
import { SessionProps } from &#39;./types&#39;;

const formSchema = z.object({
  title: z.string().min(1).max(100),
  content: z.string().min(1),
});

export default function CreatePost(props: SessionProps) {
  const [open, setOpen] = useState(false);
  const router = useRouter();
  const form = useForm&lt;z.infer&lt;typeof formSchema&gt;&gt;({
    resolver: zodResolver(formSchema),
    defaultValues: {
      title: &#39;&#39;,
      content: &#39;&#39;,
    },
  });

  async function onSubmit(values: z.infer&lt;typeof formSchema&gt;) {
    try {
      const res = await fetch(&#39;/api/posts&#39;, {
        method: &#39;POST&#39;,
        headers: { &#39;Content-Type&#39;: &#39;application/json&#39; },
        body: JSON.stringify({
          ...values,
          authorId: props.session.user?.id,
        }),
      });
      const json = await res.json();

      if (!res.ok) {
        toast(json.message);

        return;
      }

      toast(&#39;Post created!&#39;);
      form.reset();
      setOpen(false);
      router.refresh();
    } catch (error) {
      console.error(error);
    }
  }

  return (
    &lt;Dialog open={open} onOpenChange={setOpen}&gt;
      &lt;DialogTrigger asChild&gt;
        &lt;Button&gt;Create post&lt;/Button&gt;
      &lt;/DialogTrigger&gt;
      &lt;DialogContent className=&quot;max-w-[300px]&quot;&gt;
        &lt;DialogHeader className=&quot;text-left&quot;&gt;
          &lt;DialogTitle&gt;Create post&lt;/DialogTitle&gt;
          &lt;DialogDescription&gt;
            Please &lt;strong&gt;do not&lt;/strong&gt; post &lt;strong&gt;NSFW&lt;/strong&gt; content.
          &lt;/DialogDescription&gt;
        &lt;/DialogHeader&gt;
        &lt;Form {...form}&gt;
          &lt;form className=&quot;space-y-4&quot; onSubmit={form.handleSubmit(onSubmit)}&gt;
            &lt;FormField
              control={form.control}
              name=&quot;title&quot;
              render={({ field }) =&gt; (
                &lt;FormItem&gt;
                  &lt;FormLabel&gt;Title&lt;/FormLabel&gt;
                  &lt;FormControl&gt;
                    &lt;Input placeholder=&quot;Hi there!&quot; {...field} /&gt;
                  &lt;/FormControl&gt;
                  &lt;FormMessage /&gt;
                &lt;/FormItem&gt;
              )}
            /&gt;
            &lt;FormField
              control={form.control}
              name=&quot;content&quot;
              render={({ field }) =&gt; (
                &lt;FormItem&gt;
                  &lt;FormLabel&gt;Content&lt;/FormLabel&gt;
                  &lt;FormControl&gt;
                    &lt;Textarea
                      placeholder=&quot;Testing this great app!&quot;
                      {...field}
                    /&gt;
                  &lt;/FormControl&gt;
                  &lt;FormMessage /&gt;
                &lt;/FormItem&gt;
              )}
            /&gt;
            &lt;Button className=&quot;w-full&quot; type=&quot;submit&quot;&gt;
              Post
            &lt;/Button&gt;
          &lt;/form&gt;
        &lt;/Form&gt;
      &lt;/DialogContent&gt;
    &lt;/Dialog&gt;
  );
}
</code></pre>
<p><code>src/app/page.tsx</code></p>
<p>Fetch data from Prisma, as this page is a server component, we can fetch it directly.</p>
<pre><code class="language-tsx">import { authOptions } from &#39;@/libs/auth&#39;;
import { getServerSession } from &#39;next-auth&#39;;
import prisma from &#39;@/libs/db&#39;;
import CreatePost from &#39;@/components/post/create&#39;;
import Post from &#39;@/components/post&#39;;

export default async function Home() {
  const session = await getServerSession(authOptions);

  // You can fetch data to Prisma in server components
  const posts = await prisma.post.findMany({
    include: {
      author: true,
    },
  });

  return (
    &lt;&gt;
      &lt;h1 className=&quot;mb-5 font-bold text-xl&quot;&gt;Home&lt;/h1&gt;
      {session ? (
        &lt;&gt;
          &lt;CreatePost session={session} /&gt;
        &lt;/&gt;
      ) : (
        &lt;&gt;
          &lt;p&gt;You are not logged in&lt;/p&gt;
        &lt;/&gt;
      )}
      &lt;h3 className=&quot;text-lg font-semibold mt-10&quot;&gt;Posts&lt;/h3&gt;
      &lt;ul className=&quot;mt-5 space-y-2.5&quot;&gt;
        {posts.length &gt; 0 ? (
          posts.map((post) =&gt; (
            &lt;li key={post.id}&gt;
              &lt;Post {...post} session={session} /&gt;
            &lt;/li&gt;
          ))
        ) : (
          &lt;p&gt;No posts&lt;/p&gt;
        )}
      &lt;/ul&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p><code>src/components/post/item.tsx</code></p>
<pre><code class="language-tsx">&#39;use client&#39;;

import DeletePost from &#39;./delete&#39;;
import EditPost from &#39;./edit&#39;;
import { TPostProps } from &#39;./types&#39;;

export default function PostItem(props: TPostProps) {
  return (
    &lt;article className=&quot;w-max p-2 border border-slate-500 rounded-md&quot;&gt;
      &lt;header className=&quot;flex justify-between items-center&quot;&gt;
        &lt;h2 className=&quot;font-bold text-lg&quot;&gt;{props.title}&lt;/h2&gt;
        {props.session?.user?.id === props.authorId &amp;&amp; (
          &lt;section className=&quot;space-x-2&quot;&gt;
            &lt;EditPost {...props} /&gt;
            &lt;DeletePost {...props} /&gt;
          &lt;/section&gt;
        )}
      &lt;/header&gt;
      &lt;p&gt;{props.content}&lt;/p&gt;
      &lt;span className=&quot;text-sm&quot;&gt;
        Posted by {props.author?.email || &#39;anon&#39;} at{&#39; &#39;}
        {new Date(props.createdAt).toLocaleString()}
      &lt;/span&gt;
    &lt;/article&gt;
  );
}
</code></pre>
<p><code>src/components/post/edit.tsx</code></p>
<p>Create a button icon for opening a dialog rendering the post data for editing, add validation and fetch to the API endpoint.</p>
<pre><code class="language-tsx">&#39;use client&#39;;

import { useState } from &#39;react&#39;;
import { Edit } from &#39;lucide-react&#39;;
import {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from &#39;@/components/ui/dialog&#39;;
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from &#39;@/components/ui/form&#39;;
import { Input } from &#39;@/components/ui/input&#39;;
import { Textarea } from &#39;@/components/ui/textarea&#39;;
import { useForm } from &#39;react-hook-form&#39;;
import * as z from &#39;zod&#39;;
import { zodResolver } from &#39;@hookform/resolvers/zod&#39;;
import { useRouter } from &#39;next/navigation&#39;;
import { toast } from &#39;sonner&#39;;
import { Button } from &#39;@/components/ui/button&#39;;
import { TPostProps } from &#39;./types&#39;;

const formSchema = z.object({
  title: z.string().min(1).max(100),
  content: z.string().min(1),
});

export default function EditPost(props: TPostProps) {
  const [open, setOpen] = useState(false);
  const router = useRouter();
  const form = useForm&lt;z.infer&lt;typeof formSchema&gt;&gt;({
    resolver: zodResolver(formSchema),
    defaultValues: {
      title: props.title,
      content: props.content,
    },
  });

  async function onSubmit(values: z.infer&lt;typeof formSchema&gt;) {
    try {
      const res = await fetch(&#39;/api/posts&#39;, {
        method: &#39;PUT&#39;,
        headers: { &#39;Content-Type&#39;: &#39;application/json&#39; },
        body: JSON.stringify({
          ...values,
          id: props.id,
        }),
      });
      const json = await res.json();
      console.log(json);

      if (!res.ok) {
        toast(json.message);

        return;
      }

      toast(&#39;Post edited!&#39;);
      form.reset();
      setOpen(false);
      router.refresh();
    } catch (error) {
      console.error(error);
    }
  }

  return (
    &lt;Dialog open={open} onOpenChange={setOpen}&gt;
      &lt;DialogTrigger asChild&gt;
        &lt;Button variant=&quot;secondary&quot; size=&quot;icon&quot;&gt;
          &lt;Edit /&gt;
        &lt;/Button&gt;
      &lt;/DialogTrigger&gt;
      &lt;DialogContent className=&quot;max-w-[300px]&quot;&gt;
        &lt;DialogHeader className=&quot;text-left&quot;&gt;
          &lt;DialogTitle&gt;Edit post&lt;/DialogTitle&gt;
          &lt;DialogDescription&gt;
            Please &lt;strong&gt;do not&lt;/strong&gt; post &lt;strong&gt;NSFW&lt;/strong&gt; content.
          &lt;/DialogDescription&gt;
        &lt;/DialogHeader&gt;
        &lt;Form {...form}&gt;
          &lt;form className=&quot;space-y-4&quot; onSubmit={form.handleSubmit(onSubmit)}&gt;
            &lt;FormField
              control={form.control}
              name=&quot;title&quot;
              render={({ field }) =&gt; (
                &lt;FormItem&gt;
                  &lt;FormLabel&gt;Title&lt;/FormLabel&gt;
                  &lt;FormControl&gt;
                    &lt;Input placeholder=&quot;Hi there!&quot; {...field} /&gt;
                  &lt;/FormControl&gt;
                  &lt;FormMessage /&gt;
                &lt;/FormItem&gt;
              )}
            /&gt;
            &lt;FormField
              control={form.control}
              name=&quot;content&quot;
              render={({ field }) =&gt; (
                &lt;FormItem&gt;
                  &lt;FormLabel&gt;Content&lt;/FormLabel&gt;
                  &lt;FormControl&gt;
                    &lt;Textarea
                      placeholder=&quot;Testing this great app!&quot;
                      {...field}
                    /&gt;
                  &lt;/FormControl&gt;
                  &lt;FormMessage /&gt;
                &lt;/FormItem&gt;
              )}
            /&gt;
            &lt;DialogClose asChild&gt;
              &lt;Button className=&quot;w-full&quot; type=&quot;submit&quot;&gt;
                Edit post
              &lt;/Button&gt;
            &lt;/DialogClose&gt;
          &lt;/form&gt;
        &lt;/Form&gt;
      &lt;/DialogContent&gt;
    &lt;/Dialog&gt;
  );
}
</code></pre>
<p><code>src/components/post/delete.tsx</code></p>
<p>Create a button icon for opening a dialog for deleting the post, add validation and fetch to the API endpoint.</p>
<pre><code class="language-tsx">&#39;use client&#39;;

import { LucideTrash2 } from &#39;lucide-react&#39;;
import { Button } from &#39;@/components/ui/button&#39;;
import {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from &#39;@/components/ui/dialog&#39;;
import { useRouter } from &#39;next/navigation&#39;;
import { toast } from &#39;sonner&#39;;
import { TPostProps } from &#39;./types&#39;;

export default function DeletePost(props: TPostProps) {
  const router = useRouter();

  async function handleDelete() {
    try {
      const res = await fetch(&#39;/api/posts&#39;, {
        method: &#39;DELETE&#39;,
        headers: { &#39;Content-Type&#39;: &#39;application/json&#39; },
        body: JSON.stringify({
          id: props.id,
        }),
      });
      const json = await res.json();

      if (!res.ok) {
        toast(json.message);

        return;
      }

      toast(&#39;Post deleted!&#39;);
      router.refresh();
    } catch (error) {
      console.error(error);
    }
  }
  return (
    &lt;Dialog&gt;
      &lt;DialogTrigger asChild&gt;
        &lt;Button variant=&quot;destructive&quot; size=&quot;icon&quot;&gt;
          &lt;LucideTrash2 /&gt;
        &lt;/Button&gt;
      &lt;/DialogTrigger&gt;
      &lt;DialogContent className=&quot;max-w-[300px]&quot;&gt;
        &lt;DialogHeader className=&quot;text-left&quot;&gt;
          &lt;DialogTitle&gt;Delete post&lt;/DialogTitle&gt;
          &lt;DialogDescription&gt;
            Are you sure you want to &lt;strong&gt;delete&lt;/strong&gt; this post? This
            action cannot be undone.
          &lt;/DialogDescription&gt;
        &lt;/DialogHeader&gt;
        &lt;footer className=&quot;flex flex-col gap-2&quot;&gt;
          &lt;DialogClose asChild&gt;
            &lt;Button variant=&quot;secondary&quot; className=&quot;w-full&quot;&gt;
              No, keep post
            &lt;/Button&gt;
          &lt;/DialogClose&gt;
          &lt;DialogClose asChild&gt;
            &lt;Button
              onClick={handleDelete}
              variant=&quot;destructive&quot;
              className=&quot;w-full&quot;
            &gt;
              Yes, delete post
            &lt;/Button&gt;
          &lt;/DialogClose&gt;
        &lt;/footer&gt;
      &lt;/DialogContent&gt;
    &lt;/Dialog&gt;
  );
}
</code></pre>
<p><code>src/components/post/types.ts</code></p>
<pre><code class="language-ts">type SessionProps = {
  session: any;
};

type TPostProps = {
  author: {
    id: string;
    name: string | null;
    email: string | null;
    emailVerified: Date | null;
    image: string | null;
  } | null;
  id: string;
  createdAt: Date;
  updatedAt: Date;
  title: string;
  content: string;
  authorId: string | null;
  session: any;
};

export type { SessionProps, TPostProps };
</code></pre>
<p><code>src/components/sign-out.tsx</code></p>
<p>A simple sign out button.</p>
<pre><code class="language-tsx">&#39;use client&#39;;

import { signOut } from &#39;next-auth/react&#39;;
import { Button } from &#39;./ui/button&#39;;

export default function SignOut() {
  return &lt;Button onClick={() =&gt; signOut()}&gt;Sign out&lt;/Button&gt;;
}
</code></pre>
<p><code>src/components/navbar.tsx</code></p>
<p>Render the sign out or sign in button depending if the user is logged in or not.</p>
<pre><code class="language-tsx">import Link from &#39;next/link&#39;;
import { Button } from &#39;./ui/button&#39;;
import { getServerSession } from &#39;next-auth&#39;;
import { authOptions } from &#39;@/libs/auth&#39;;
import SignOut from &#39;./sign-out&#39;;

export default async function Navbar() {
  const session = await getServerSession(authOptions);

  return (
    &lt;nav className=&quot;w-full p-4 border-b flex justify-between items-center&quot;&gt;
      &lt;section&gt;
        &lt;Button variant=&quot;link&quot; className=&quot;px-0 font-semibold text-lg&quot;&gt;
          &lt;Link href=&quot;/&quot;&gt;Fullstack app&lt;/Link&gt;
        &lt;/Button&gt;
      &lt;/section&gt;
      &lt;section&gt;
        {session ? (
          &lt;SignOut /&gt;
        ) : (
          &lt;Button asChild&gt;
            &lt;Link href=&quot;/auth&quot;&gt;Sign in&lt;/Link&gt;
          &lt;/Button&gt;
        )}
      &lt;/section&gt;
    &lt;/nav&gt;
  );
}
</code></pre>
<p><code>src/app/layout.tsx</code></p>
<p>Add your <strong>Navbar</strong> and <strong>Toaster</strong> components and some styles.</p>
<pre><code class="language-tsx">import { Inter } from &#39;next/font/google&#39;;
import Navbar from &#39;@/components/navbar&#39;;
import { Toaster } from &#39;@/components/ui/sonner&#39;;
import &#39;./globals.css&#39;;

const inter = Inter({ subsets: [&#39;latin&#39;] });

interface Props extends React.PropsWithChildren {}

export default function RootLayout(props: Props) {
  return (
    &lt;html lang=&quot;en&quot;&gt;
      &lt;body className={inter.className}&gt;
        &lt;Navbar /&gt;
        &lt;main className=&quot;px-4 py-8&quot;&gt;{props.children}&lt;/main&gt;
        &lt;Toaster /&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  );
}
</code></pre>
<h2>4. Add CRUD functionality</h2>
<p>Now we can add Create, Read, Update and Delete functionality to our app.</p>
<p><code>prisma/schema.prisma</code></p>
<p>Update your Prisma schema adding to User model a relationship with Post model:</p>
<pre><code class="language-prisma">generator client {
  provider = &quot;prisma-client-js&quot;
}

datasource db {
  provider = &quot;postgresql&quot;
  url      = env(&quot;DATABASE_URL&quot;)
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
  posts         Post[]
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Post {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  title     String
  content   String
  author    User     @relation(fields: [authorId], references: [id])
  authorId  String
}
</code></pre>
<p>Generate a new Prisma migration:</p>
<pre><code class="language-bash">npx prisma migrate dev --name add-posts
</code></pre>
<p>Now, create a <code>src/app/api/posts/route.ts</code> file with a <strong>POST</strong>, <strong>PUT</strong> and <strong>DELETE</strong> async functions:</p>
<pre><code class="language-ts">import prisma from &#39;@/libs/db&#39;;
import { NextRequest, NextResponse } from &#39;next/server&#39;;

export async function POST(req: Request) {
  try {
    if (!req.body) {
      return NextResponse.json({
        ok: false,
        status: 400,
        message: &#39;Data required&#39;,
      });
    }

    const json = await req.json();
    const res = await prisma.post.create({
      data: json,
    });

    return NextResponse.json({
      ok: true,
      status: 201,
      data: res,
    });
  } catch (error) {
    if (error instanceof Error) {
      return NextResponse.json({
        ok: false,
        status: 500,
        message: error.message,
      });
    }

    return NextResponse.json({
      ok: false,
      status: 500,
      message: &#39;Internal server error&#39;,
    });
  }
}

export async function PUT(req: NextRequest) {
  try {
    const body = await req.json();
    const res = await prisma.post.update({
      where: { id: body.id },
      data: {
        title: body.title,
        content: body.content,
      },
    });

    return NextResponse.json({
      ok: true,
      status: 200,
      data: res,
    });
  } catch (error) {
    if (error instanceof Error) {
      return NextResponse.json({
        ok: false,
        status: 500,
        message: error.message,
      });
    }

    return NextResponse.json({
      ok: false,
      status: 500,
      message: &#39;Internal server error&#39;,
    });
  }
}

export async function DELETE(req: NextRequest) {
  try {
    const body = await req.json();
    const res = await prisma.post.delete({
      where: { id: body.id },
    });

    return NextResponse.json({
      ok: true,
      status: 200,
      data: res,
    });
  } catch (error) {
    if (error instanceof Error) {
      return NextResponse.json({
        ok: false,
        status: 500,
        message: error.message,
      });
    }

    return NextResponse.json({
      ok: false,
      status: 500,
      message: &#39;Internal server error&#39;,
    });
  }
}
</code></pre>
<p>Try creating a post in the home.</p>
<p>The page will refresh and you&#39;ll see the post, as you created it, only you can edit or delete it.</p>
<h2>5. Conclusion</h2>
<p>As you can see, create a fullstack app with Next.js and Prisma is really easy.</p>
<p>Of course, it could be improved, adding server side validation for inputs, adding pagination for posts in the home, etc.</p>
<p>If you want to work together, email me to <a href="mailto:contact@juancman.dev" target="_blank" rel="noopener noreferrer">contact@juancman.dev</a>.</p>
]]></description>
            <link>https://juancman.dev/portfolio/build-a-fullstack-app</link>
            <guid isPermaLink="false">https://juancman.dev/portfolio/build-a-fullstack-app</guid>
            <category><![CDATA[Next.js]]></category>
            <category><![CDATA[PostgreSQL]]></category>
            <category><![CDATA[Prisma]]></category>
            <category><![CDATA[Auth.js]]></category>
            <category><![CDATA[tailwindcss]]></category>
            <category><![CDATA[shadcn/ui]]></category>
            <dc:creator><![CDATA[Juan Manzanero]]></dc:creator>
            <pubDate>Thu, 18 Jan 2024 06:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Next Intl Blog Template]]></title>
            <description><![CDATA[<h1>Next Intl Blog Template</h1>
<p><img src="/portfolio/next-intl-blog-template/banner.png" alt="Next Intl Blog Template banner"><br><em>Next Intl Blog Template banner</em></p>
<p><PostData
  date='December 18, 2023'
  author='Juan Manzanero'
  website='https://next-intl-blog-template.vercel.app/en'
  github='https://github.com/juancmandev/next-intl-blog-template'
/></p>
<h2>Overview</h2>
<p>Recently I update this website, and as you may know, is an <strong>English and Spanish content website</strong>.</p>
<p>I&#39;m not using a translation plugin, instead I write every work in both English and Spanish.</p>
<p>Thanks to Next.js and <a href="https://next-intl-docs.vercel.app/" target="_blank" rel="noopener noreferrer">next-intl</a> I can achieve this, rendering routes for each language in the website, accessing a dictionary that contains the content translated by me.</p>
<p>For the .mdx files, I created a directory for each language, and inside of those directories it contains the content in both languages too.</p>
<h2>How to use</h2>
<p>This template is an extension of <a href="https://next-intl-docs.vercel.app/" target="_blank" rel="noopener noreferrer">next-intl</a>, chek the <a href="https://next-intl-docs.vercel.app/docs/getting-started" target="_blank" rel="noopener noreferrer">getting started</a> to learn the basics, the purpouse of the template is to create a simple layout for future customization.</p>
<h3>Add or remove locales</h3>
<p>You can add or remove locales in the <code>src/lang/locales.ts</code> file.</p>
<pre><code class="language-ts">export type locales = &#39;en&#39; | &#39;es&#39;;

export const localesList: locales[] = [&#39;en&#39;, &#39;es&#39;];
</code></pre>
<p>Just add or remove a locale from the <code>locales</code> const, and add or remove it from the list.</p>
<p>The first item in the <code>localesList</code> must be the default locale.</p>
<p>The list is used for static generation of the routes in <code>src/app/[locale]/layout.tsx</code>.</p>
<pre><code class="language-ts">import { localesList } from &#39;@/lang/locales&#39;;

export function generateStaticParams() {
  return localesList.map((locale) =&gt; ({ locale }));
}
</code></pre>
<p>Remember to update the matcher in <code>src/middleware.ts</code>.</p>
<pre><code class="language-ts">//...

export const config = {
  matcher: [&#39;/&#39;, &#39;/(en|es)/:path*&#39;],
};
</code></pre>
<p>And of course, update your <code>src/lang/[locale].json</code> files.</p>
<h3>Content creation</h3>
<p>Use <code>src/content/[locale]</code> for create content, in the <code>/[locale]/</code> directory ceate the directory for each purpouse, for example: <code>/[locale]/blog</code>.</p>
<p>Inside create the .mdx file with an unique name, the name will be used as the slug for create the static page for that post.</p>
<p>For create a blog section, you&#39;ll use the <em>getAllContent</em> function in your route, for example: <code>src/app/[locale]/blog/[slug]/page.tsx</code>.</p>
<pre><code class="language-tsx">import { Mdx } from &#39;@/components&#39;;
import { TParamsLocale, TPage, TSlugLang } from &#39;@/types&#39;;
import { Metadata } from &#39;next&#39;;
import { getAllContent, getContent } from &#39;@/utils/getContent&#39;;

export async function generateStaticParams(
  props: TParamsLocale
): Promise&lt;TSlugLang[]&gt; {
  const blogs = await getAllContent(props.params.locale, &#39;blog&#39;);

  if (!blogs) return [];

  return blogs.map((blog) =&gt; ({
    slug: blog.slug,
    locale: props.params.locale,
  }));
}

//...
</code></pre>
<p>This will create each static page for each blog post.</p>
<p>You can get the metadata of the .mdx file too.</p>
<pre><code class="language-tsx">//...

export async function generateMetadata(props: TPage): Promise&lt;Metadata&gt; {
  const blog = await getContent(props.params.locale, &#39;blog&#39;, props.params.slug);

  if (!blog) return {};

  return {
    title: blog.title,
    //...
  };
}

//...
</code></pre>
<p>Then, render the content using the <em>Mdx</em> component.</p>
<pre><code class="language-tsx">//...

export default async function Page(props: TPage) {
  const post = await getContent(props.params.locale, &#39;blog&#39;, props.params.slug);

  if (!post) return null;

  return &lt;Mdx code={post.body.code} /&gt;;
}
</code></pre>
<p><a href="https://github.com/juancmandev/next-intl-blog-template" target="_blank" rel="noopener noreferrer">You can fork this template here</a></p>
<h2>Contact</h2>
<p>If you want <strong>to work together</strong> in a website with internationalization with Next.js, email me at <a href="mailto:contact@juancman.dev" target="_blank" rel="noopener noreferrer">contact@juancman.dev</a></p>
]]></description>
            <link>https://juancman.dev/portfolio/next-intl-blog-template</link>
            <guid isPermaLink="false">https://juancman.dev/portfolio/next-intl-blog-template</guid>
            <category><![CDATA[Next.js]]></category>
            <category><![CDATA[next-intl]]></category>
            <category><![CDATA[tailwindcss]]></category>
            <dc:creator><![CDATA[Juan Manzanero]]></dc:creator>
            <pubDate>Mon, 18 Dec 2023 06:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Human to JS]]></title>
            <description><![CDATA[<h1>Human to JS</h1>
<p><img src="/portfolio/human-to-js/banner.png" alt="Human to JS banner"><br><em>Human to JS diagram</em></p>
<p><PostData
  date='April 4, 2023'
  author='Juan Manzanero'
  website='https://human-to-js.juancman.dev'
  github='https://github.com/juancmandev/human-to-js'
/></p>
<h2>Background</h2>
<p>I’m always looking to grow my career by learning new technologies as well known Software Engineer; however, that could be dangerous because Software Engineer is not about using the ultimate tech stack but making things happen.</p>
<h2>Inspiration source</h2>
<p>I was checking Twitter until I found a tweet where a person created a side project over a weekend. That project is <a href="https://www.sqltranslate.app/" target="_blank" rel="noopener noreferrer">SQL Translator</a>, a simple UI to put text input describing a query; then you get the query into SQL, simple!</p>
<p><a href="https://twitter.com/whoiskatrin?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1634973237829599233%7Ctwgr%5Eb49b9d28e6ea7383ef16ea3c8c6040656ff0c944%7Ctwcon%5Es1_&ref_url=https%3A%2F%2Fpublish.twitter.com%2F%3Fquery%3Dhttps3A2F2Ftwitter.com2Fwhoiskatrin2Fstatus2F1634973237829599233widget%3DTweet" target="_blank" rel="noopener noreferrer">@whoiskatrin</a> used ChatGPT API to send a prompt typed by the user, and then show SQL response into a component to copy to the clipboard. That was enough to get the deserved attention of the community. <a href="https://twitter.com/whoiskatrin/status/1634973237829599233" target="_blank" rel="noopener noreferrer">Tweet link</a></p>
<h2>My idea</h2>
<blockquote>
<p><em>“Why not a web app to type a prompt to generate JavaScript code?”</em></p>
</blockquote>
<p>So I started to build my idea using this tech stack:</p>
<ul>
<li><strong>Next.js</strong>: Web framework to build the UI and Next.js provides you with an API directory to communicate with ChatGPT API</li>
<li><strong>MUI</strong>: To use the UI components and as a design system</li>
<li><strong>Formik &amp; Yup</strong>: To manage the state of the prompt form and create validation schemas</li>
</ul>
<p>Using all these technologies I build a simple UI with a MUI Card component, then I created a form where I manage all the inputs with Formik, the text and select inputs are directly from MUI, and to create the validation schema I used Yup to mark as required those fields and don’t send them empty.</p>
<p>With the UI finished, I started creating the endpoint in the API directory to consume ChatGPT’s API, just using a fetch like <a href="https://twitter.com/whoiskatrin?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1634973237829599233%7Ctwgr%5Eb49b9d28e6ea7383ef16ea3c8c6040656ff0c944%7Ctwcon%5Es1_&ref_url=https%3A%2F%2Fpublish.twitter.com%2F%3Fquery%3Dhttps3A2F2Ftwitter.com2Fwhoiskatrin2Fstatus2F1634973237829599233widget%3DTweet" target="_blank" rel="noopener noreferrer">@whoiskatrin</a>’s project, indicating which OpenAI model to use, in this case, <em>text-davinci-003</em>, you can learn more about those models <a href="https://platform.openai.com/docs/api-reference/models/list" target="_blank" rel="noopener noreferrer">here</a>. Obviously, in that request, I send the prompt from the user into a string indicating ChatGPT to only give me the code, without comments or more results.</p>
<h2>Added value</h2>
<p>Yes, there’re options like GitHub Copilot that resolve that problem, that’s why I added a select option to choose if the syntax should be an arrow function or a simple function.</p>
<p>I’ll add more features, like a TypeScript option, and use a TS Interface to use as a reference, but now I’m working on more projects!</p>
<h2>Inspiring people!</h2>
<p>The cool thing about side projects is that inspires people like us, we can use our tech skill that serves the bread on the table to transform ideas into products, and products into a community, as <a href="https://twitter.com/serudda" target="_blank" rel="noopener noreferrer">@Serudda</a> talks in this <a href="https://www.youtube.com/watch?v=LXgPNdw8avI&t" target="_blank" rel="noopener noreferrer">video</a> (video audio in Spanish).</p>
]]></description>
            <link>https://juancman.dev/portfolio/human-to-js</link>
            <guid isPermaLink="false">https://juancman.dev/portfolio/human-to-js</guid>
            <category><![CDATA[ChatGPT]]></category>
            <category><![CDATA[Next.js]]></category>
            <category><![CDATA[JavaScript]]></category>
            <category><![CDATA[Vercel]]></category>
            <dc:creator><![CDATA[Juan Manzanero]]></dc:creator>
            <pubDate>Fri, 14 Apr 2023 06:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Workarise]]></title>
            <description><![CDATA[<h1>Workarise</h1>
<p><img src="/portfolio/workarise/banner.png" alt="Workarise Banner"><br><em>Workarise Banner</em></p>
<p><PostData
  date='April 13, 2023'
  author='Juan Manzanero'
  website='https://workarise.com'
/></p>
<h2>Overview</h2>
<p><a href="http://workarise.com" target="_blank" rel="noopener noreferrer">Workarise</a> is a Team Manager Software as a Service to create task cards assigning people, set a start and due date, add attachments files, etc.</p>
<p>You can use the Calendar to see the tasks&#39; due dates and schedule Google Meet events authorizing the use of your Google Calendar. You can edit and delete events which sync with your Google Calendar and guests&#39; Google Calendars. The Gantt provides you with a timeline to check task duration.</p>
<p>The web app is developed with <a href="https://react.dev/" target="_blank" rel="noopener noreferrer">React.js</a>, using <a href="https://vitejs.dev/" target="_blank" rel="noopener noreferrer">Vite.js</a> to run the development environment. For functionality like modals, and popovers we use <a href="https://mui.com/" target="_blank" rel="noopener noreferrer">MUI</a>. To manage the state of components we’re using useContext.</p>
<p>To create Google Meet events and sync the calendar we&#39;d develop a small Node.js API to use Google OAuth 2 API, as we need to prompt our users to give access to their Google Calendars.</p>
<p>Currently, Workarise is in the first version, using <a href="https://firebase.google.com/" target="_blank" rel="noopener noreferrer">Firebase</a> to authenticate users and store raw data and files. Firebase uses <a href="https://firebase.google.com/docs/firestore" target="_blank" rel="noopener noreferrer">Firestore</a>, a NoSQL DB, however we’re developing an API using <a href="https://www.djangoproject.com/" target="_blank" rel="noopener noreferrer">Django</a> running on <a href="https://cloud.google.com/run" target="_blank" rel="noopener noreferrer">Cloud Run</a> connected to <a href="https://cloud.google.com/sql" target="_blank" rel="noopener noreferrer">Cloud SQL</a> to a MySQL instance, as we’ll be using a SQL DB in the future. Currently the web app and landing are deployed on Firebase Hosting, but we’ll move the landing page to Vercel, and it’ll be updated to use Next.js in the future to optimize SEO and publish blog posts.</p>
<h2>My impact in Workarise</h2>
<p>Currently, we’re developing an MVP, and everyone is working part-time on this project. I joined in December, but before there wasn’t a product that users can use, so as I was the only Frontend Engineer at that moment I taked full responsibility for delivering something that can be considered an MVP.</p>
<p>It took me like 3 months to achieve that, I updated some dependencies of the project to improve the development flow, and I suggested using Firebase as Backend and Hosting.</p>
<p>Thanks to all this we got our first users and feedback, so we’re working on that feedback to keep improving our app, our users like the design and simplicity!</p>
<p>At the moment there’re 3 engineers in the team, 2 on the front (including me) and 1 on the back, but I’m helping to our Backend Engineer to deploy on GCP to production the API and DB, and I&#39;m guiding the new Frontend to deliver new features, he’d developed the responsive design and some features to complement the task cards.</p>
<p>I’m happy to test my skills in this project, it’s not easy to take more responsibility with less than 2 years of labor experience, and it’d help me to grow a lot in these months.</p>
<p>Even if the market doesn’t consider my years of experience as a senior, I think that doesn’t matter at all, the only thing that matters is that you can understand why you’re using code, to create solutions and reach people across their computers.</p>
]]></description>
            <link>https://juancman.dev/portfolio/workarise</link>
            <guid isPermaLink="false">https://juancman.dev/portfolio/workarise</guid>
            <category><![CDATA[React.js]]></category>
            <category><![CDATA[Vite.js]]></category>
            <category><![CDATA[MUI]]></category>
            <category><![CDATA[Firebase]]></category>
            <category><![CDATA[GCP]]></category>
            <category><![CDATA[Node.js]]></category>
            <dc:creator><![CDATA[Juan Manzanero]]></dc:creator>
            <pubDate>Thu, 13 Apr 2023 06:00:00 GMT</pubDate>
        </item>
    </channel>
</rss>